<html>
<head>
<title>Test for fcrbm.js Generation</title>
<script src="https://code.jquery.com/jquery-3.0.0.min.js"></script>
<!--<script src="http://cdnjs.cloudflare.com/ajax/libs/mathjs/3.2.1/math.min.js"></script>-->
<script src="../node_modules/linear-algebra/dist/linear-algebra.min.js"
<script src="sandbox.gen.js"></script>
<style>
#activCanvas {
    width: 70%; 
    height: 750px; 
    border:rgba(0, 0, 0, 1) solid 1px;
    /*background: black;*/
}
</style>
</head>
<body>

<canvas id="activCanvas"></canvas>

<script language="javascript">
// This is basically going to be a port of Taylor's Matlab code to javascript

var inputModel; 
var tm; 

var genParams = {
    numGibbs: 2,
    initNoise: 0.05,
};



var linearAlgebra =  linearAlgebra(),
    Vector = linearAlgebra.Vector,
    Matrix = linearAlgebra.Matrix;


$.getJSON('testmodel1.json', function (j) {
    console.log('loaded');
    inputModel = j.TestModel1;

    inputModel.numdims = inputModel.visbiases.length;
    inputModel.lf = 1;

    vishistory = Matrix.zero(inputModel.nt, inputModel.numdims).plusEach_(1);    

    labels = Matrix.zero(30, 8).plusEach_(1);
    
    generate(inputModel,genParams, 30, labels, vishistory);

});

var lastTime = 0;
var timeCount = 0;
function timeStamp() {
    if (lastTime == 0) {
        lastTime = Date.now();                
    }
    timeCount++;
    console.log(timeCount +": " + (Date.now()-lastTime));
    lastTime = Date.now();
}

var visible;
/*
model: model parameters
genParams: generation parameters
numFrames: number of frames to generate
history: history 
*/
function generate(model, genParams, numFrames, labels, vishistory) {
    console.log("Generating ...");

    timeStamp(1);

    visible     = Matrix.zero(numFrames + model.nt, model.numdims);
    poshidprobs = Matrix.zero(numFrames, model.numhid);
    hidstates   = Matrix.zero(numFrames, model.numhid);

    for(i=0;i<vishistory.data.length;i++) {
        visible.data[i] = vishistory.data[i];
    }
    

    // de-objectifying and inlining everything

    numLabels = labels.data[0].length;

    labelfeat   = new Matrix(model.labelfeat);
    featfac     = new Matrix(model.featfac);
    pastfacA    = new Matrix(model.pastfacA);
    pastfacB    = new Matrix(model.pastfacB);
    hidfacB     = new Matrix(model.hidfacB);
    hidfac      = new Matrix(model.hidfac);
    nt          = model.nt;
    numdims     = model.numdims;
    numhid      = model.numhid;
    hidbiases   = new Matrix(model.hidbiases);
    visfac      = new Matrix(model.visfac);
    visfacA     = new Matrix(model.visfacA);
    visbiases   = new Matrix(model.visbiases);
    lf          = model.lf;

    initNoise   = genParams.initNoise;

    timeStamp(2);

    for (var f = nt; f < numFrames + nt; f++ ) {
        console.log(f+': frame '+(f-nt +1));
        timeStamp(3);
        // init the visible using the last frame + noise
        
        visible.data[f] = (new Matrix(visible.data[f-1]).plusEach(Math.random() * initNoise)).data[0];

        timeStamp(4);

        // build the past by copying from history
        // for hh=nt:-1:1 %note reverse order
        // past(:,numdims*(nt-hh)+1:numdims*(nt-hh+1)) = visible(tt-hh,:);
        past = Matrix.zero(1 , nt * numdims);
        
        for (var hh = nt-1; hh >= 0; hh--) {            
            // var p = visible.data[f-hh];

            // past.subset(math.index(math.range(0,1),
            //                 math.range((nt-hh-1)*numdims,
            //                             (nt-hh)*numdims) 
            //                         ),p);
            for (i=numdims*(nt-hh-1);i<numdims*(nt-hh);i++)
                for (j=0;j<numdims;j++)
                    past.data[0][i+j] = visible.data[f-hh][j]; 
        }
        console.log(past);
        timeStamp(5);
        // Calculate the history and features considering factors
        
        // if (lf )
        //     features = labels(tt-lastFrame,:)*labelfeat;
        // else
        //     features = labels(tt-lastFrame,:);
        // end
        
        
        var features = new Matrix(labels.data[f-nt]);        
        if (lf == 1)
            features.dot_(labelfeat);        

        timeStamp(5.5);
        // %undirected model
        // yfeat = features*featfac;
        
        var yfeat = features.dot(featfac);

        // %autoregressive model
        // ypastA = past*pastfacA;
        // yfeatA = features*featfac;
        
        var ypastA = past.dot(pastfacA);
        var yfeatA = features.dot(featfac);

        // %directed vis-hid model
        // ypastB = past*pastfacB;
        // yfeatB = features*featfac;

        var ypastB = past.dot(pastfacB);
        var yfeatB = features.dot(featfac); 
        timeStamp(6);
        // %constant term during inference
        // %(not dependent on visibles)
        // constinf = -(ypastB.*yfeatB)*hidfacB' - hidbiases;
        
        // var t = math.dotMultiply(ypastB,yfeatB);
        // t = math.multiply(-1,t);
        // t = math.multiply(t,math.transpose(hidfacB));
        // var hidbiases2 = math.matrix(hidbiases).clone();
        // hidbiases2.resize([1,hidbiases.length]);
        // var constinf =  math.subtract(t,hidbiases2);


        var t = ypastB.mul(yfeatB);
        t.mulEach_(-1);
        t.dot_(hidfacB.trans());
        // var hidbiases2 = Matrix.reshapeFrom(hidbiases,1,hidbiases.length);
        var constinf = t.minus(hidbiases);
        timeStamp(7);

        // %constant term during reconstruction
        // %(not dependent on hiddens)
        // constrecon = (yfeatA.*ypastA)*visfacA' + visbiases;

        // var t2 = math.dotMultiply(yfeatA,ypastA);
        // t2 = math.multiply(t2,math.transpose(visfacA));
        // var visbiases2 = math.matrix(visbiases).clone();
        // visbiases2.resize([1,visbiases.length]);
        // var constrecon =  math.add(t2,visbiases2);


        var t2 = yfeatA.mul(ypastA);        
        t2.dot_(visfacA.trans());
        // var visbiases2 = Matrix.reshapeFrom(visbiases,1,visbiases.length);
        var constrecon = t2.plus(visbiases);        
        // Gibbs sampling
        
        timeStamp(8);
        
        
        for (var g = 0; g < genParams.numGibbs; g++) {
            // yvis = visible(tt,:)*visfac;                              
            var yvis = new Matrix(visible.data[f]);             
            yvis.dot_(visfac);

            // %pass through sigmoid
            // %only part from "undirected" model changes
            // poshidprobs(tt,:) = 1./(1 + exp(-(yvis.*yfeat)*hidfac' + constinf));

            var bottomup = yvis.mul(yfeat);
                bottomup.mulEach_(-1);
                bottomup.dot_(hidfac.trans());

            var et = bottomup.plus(constinf);
            et.sigmoid_();

                // et.map_(function(v) {
                //     return 1.0/(1+Math.exp(v));    
                // });
                        
            poshidprobs.data[f] = et.data[0];                        
            // %Activate the hidden units
            // hidstates(tt,:) = single(poshidprobs(tt,:) > rand(1,numhid));
                        
            var act = new Matrix(poshidprobs.data[f]);
            
            act.map_(function(v) {
                if (v > Math.random())
                    return 1;
                else
                    return 0;
            });
            // for (i=0;i<act.length;i++)
            
            hidstates.data[f] = act.data[0];

            // yhid = hidstates(tt,:)*hidfac;            
            var yhid = act.dot(hidfac);

            // %NEGATIVE PHASE
            // %Don't add noise at visibles
            // %Note only the "undirected" term changes
            // visible(tt,:) = (yfeat.*yhid)*visfac' + constrecon;

            var v = yfeat.mul(yhid).dot(visfac.trans()).plus(constrecon);
            visible.data[f] = v.data[0];
            
        timeStamp(9);
        }                             
        var yhid_ = new Matrix(poshidprobs.data[f]);
        // Meanfield
        // yhid_ = poshidprobs(tt,:)*hidfac; %smoothed version        
        yhid_.dot_(hidfac);

        // Approximation 
        // visible(tt,:) = (yfeat.*yhid_)*visfac' + constrecon;    
        
        var v = yfeat.mul(yhid_).dot(visfac.trans()).plus(constrecon);
        visible.data[f] = v.data[0];
        
        updateHidAc2(f,poshidprobs.data[f]);
    }

    timeStamp(10);
    console.log("Done generating!");
}

bb = [];
function updateHidAc2(f, aa) { 
    bb = aa;

    var canvas = document.getElementById('activCanvas');
    var context = canvas.getContext("2d");	
    var radius = 0.2;
    for (var i=0; i < aa.length; i++) {
        context.beginPath();
        context.arc(f*2, i/4, radius, 0, 2 * Math.PI, false);
        context.fillStyle = 'rgba(0,0,0,'+ (aa[i] * 1.2)  +')';
        context.fill();
    }
    
}
</script>

</body>


</html>