<html>
<head>
<title>Test for fcrbm.js Generation</title>
<script src="https://code.jquery.com/jquery-3.0.0.min.js"></script>
<script src="http://cdnjs.cloudflare.com/ajax/libs/mathjs/3.2.1/math.min.js"></script>
<script src="sandbox.gen.js"></script>

</head>
<body>

<script language="javascript">
// This is basically going to be a port of Taylor's Matlab code to javascript

var inputModel; 
var tm; 

var genParams = {
    numGibbs: 30,
    initNoise: 0.05,
};


$.getJSON('testmodel1.json', function (j) {
    console.log('loaded');
    inputModel = j.TestModel1;

    inputModel.numdims = inputModel.visbiases.length;
    inputModel.lf = 1;

    vishistory = math.ones(inputModel.nt, inputModel.numdims);

    labels = math.ones(4, 8);
    generate(inputModel,genParams, 4, labels, vishistory);

});

var visible;
/*
model: model parameters
genParams: generation parameters
numFrames: number of frames to generate
history: history 
*/
function generate(model, genParams, numFrames, labels, vishistory) {
    console.log("Generating ...");

    visible     = math.zeros(numFrames+model.nt, model.numdims);
    poshidprobs = math.zeros(numFrames, model.numhid);
    hidstates = math.zeros(numFrames, model.numhid);

    visible.subset(math.index(math.range(0, model.nt),
                              math.range(0,model.numdims)), 
                   vishistory);
        
    for (f = model.nt; f < numFrames + model.nt; f++ ) {
    console.log('frame '+(f-model.nt +1));
    // init the visible using the last frame + noise

    somenoise = math.zeros(1, model.numdims);
    somenoise = somenoise.map(function (value, index, matrix) {
        return math.random() * genParams.initNoise;
    });

    pastNoise = math.add(visible.subset(math.index(f-1, math.range(0,model.numdims))),
                  somenoise);

    visible.subset(math.index(f,math.range(0,model.numdims)),
                    pastNoise);

    // build the past by copying from history
    // for hh=nt:-1:1 %note reverse order
    // past(:,numdims*(nt-hh)+1:numdims*(nt-hh+1)) = visible(tt-hh,:);
    past = math.zeros(1, model.nt * model.numdims);

    for (hh = model.nt-1; hh >= 0; hh--) {
        p = math.subset(visible, 
                        math.index(math.range(f-model.nt,f-model.nt+1),
                                    math.range(0,model.numdims)));
        
        past.subset(math.index(math.range(0,1),
                        math.range((model.nt-hh-1)*model.numdims,
                                    (model.nt-hh)*model.numdims) 
                                ),p);
    }
    

    // Calculate the history and features considering factors
    
    // if (lf )
    //     features = labels(tt-lastFrame,:)*labelfeat;
    // else
    //     features = labels(tt-lastFrame,:);
    // end
    numLabels = math.size(labels).get([1]);
    ll = math.subset(labels,
                     math.index(math.range(f-model.nt,f-model.nt+1),
                                math.range(0,numLabels)));

    if (model.lf == 1)
        features =  math.multiply(ll, model.labelfeat);
    else
        features = ll;

    // %undirected model
    // yfeat = features*featfac;
    
    yfeat = math.multiply(features, model.featfac);

    // %autoregressive model
    // ypastA = past*pastfacA;
    // yfeatA = features*featfac;
    
    ypastA = math.multiply(past, model.pastfacA);
    yfeatA = math.multiply(features, model.featfac);

    // %directed vis-hid model
    // ypastB = past*pastfacB;
    // yfeatB = features*featfac;

    ypastB = math.multiply(past, model.pastfacB);
    yfeatB = math.multiply(features, model.featfac); 
    
    // %constant term during inference
    // %(not dependent on visibles)
    // constinf = -(ypastB.*yfeatB)*hidfacB' - hidbiases;
    
    t = math.dotMultiply(ypastB,yfeatB);
    t = math.multiply(-1,t);
    t = math.multiply(t,math.transpose(model.hidfacB));
    hidbiases = math.matrix(model.hidbiases).clone();
    hidbiases.resize([1,model.hidbiases.length]);
    constinf =  math.subtract(t,hidbiases);

    // %constant term during reconstruction
    // %(not dependent on hiddens)
    // constrecon = (yfeatA.*ypastA)*visfacA' + visbiases;

    t = math.dotMultiply(yfeatA,ypastA);
    t = math.multiply(t,math.transpose(model.visfacA));
    visbiases = math.matrix(model.visbiases).clone();
    visbiases.resize([1,model.visbiases.length]);
    constrecon =  math.add(t,visbiases);

    // Gibbs sampling
    
    for (g = 0; g < genParams.numGibbs; g++) {
        // yvis = visible(tt,:)*visfac;        
        yvis = math.multiply(
            visible.subset(math.index(f,math.range(0,model.numdims))),
            model.visfac);

        // %pass through sigmoid
        // %only part from "undirected" model changes
        // poshidprobs(tt,:) = 1./(1 + exp(-(yvis.*yfeat)*hidfac' + constinf));

        bottomup = math.dotMultiply(yvis,yfeat);
        bottomup = math.multiply(-1,bottomup);
        bottomup = math.multiply(bottomup,math.transpose(model.hidfac));

        et = math.add(1,math.exp(math.add(bottomup,constinf)));
        et = math.dotDivide(1,et);
        poshidprobs.subset(math.index(f+model.nt,math.range(0,model.numhid)),et);

        // %Activate the hidden units
        // hidstates(tt,:) = single(poshidprobs(tt,:) > rand(1,numhid));
        
        // yhid = hidstates(tt,:)*hidfac;
        
        // %NEGATIVE PHASE
        // %Don't add noise at visibles
        // %Note only the "undirected" term changes
        // visible(tt,:) = (yfeat.*yhid)*visfac' + constrecon;
    }
        
        
        
    

    // Meanfield

    // Approximation 

    }
}

</script>

</body>


</html>